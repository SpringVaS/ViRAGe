package com.fr2501.virage.isabelle;

import java.nio.file.Path;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import de.unruh.isabelle.control.Isabelle;
import de.unruh.isabelle.control.Isabelle.Setup;
import de.unruh.isabelle.mlvalue.ListConverter;
import de.unruh.isabelle.mlvalue.MLFunction;
import de.unruh.isabelle.mlvalue.MLFunction0;
import de.unruh.isabelle.mlvalue.MLValue;
import de.unruh.isabelle.mlvalue.StringConverter;
import de.unruh.isabelle.pure.Context;
import de.unruh.isabelle.pure.Implicits;
import de.unruh.isabelle.pure.Theory;
import de.unruh.isabelle.pure.Thm;
import de.unruh.isabelle.mlvalue.MLValue.Converter;
import scala.Some;
import scala.collection.JavaConverters;
import scala.concurrent.ExecutionContext;
import scala.concurrent.Future;

import static scala.concurrent.ExecutionContext.global;

/**
 * 
 * TODO
 *
 */
public class ScalaIsabelleFacade {
	private static final String ISA_SEPARATOR = ".";
	private static final ListConverter<String> lConv = new ListConverter<String>(new JavaStringConverter());
	
	private String sessionDir;
	private String sessionName;
	
	private Set<String> theoryNames;
	private Map<String, Map<String, String>> theorems;
	private Map<String, Map<String, String>> functionsAndDefinitions;
	
	private Setup setup;
	private Isabelle isabelle;
	
	public ScalaIsabelleFacade(String sessionDir, String sessionName) {
		this.sessionDir = sessionDir;
		this.sessionName = sessionName;
		
		this.theoryNames = new HashSet<String>();
		
		List<Path> sessionDirs = new LinkedList<Path>();
		sessionDirs.add(Path.of(this.sessionDir));
		
		this.setup = new Setup(Path.of("/opt/isabelle"), 
				sessionName, 
				new Some<Path>(Path.of("/home/fabian/.isabelle")), 
				Path.of(sessionDir), 
				JavaConverters.asScalaIteratorConverter(sessionDirs.iterator()).asScala().toSeq(), 
				true, 
				null);
		
		this.isabelle = new Isabelle(setup);
		this.init();
	}
	
	private void init() {
		this.extractTheoryNames();
		this.extractTheorems();
		this.extractFunctionsAndDefinitions();
		
		isabelle.destroy();
	}
	
	private void extractTheoryNames() {
		String prefix = this.sessionName + ISA_SEPARATOR;
		
		MLFunction0<scala.collection.immutable.List<String>> mlFun = 
				MLFunction0.compileFunction0("Thy_Info.get_names", this.isabelle, global(), lConv);
		var thys = mlFun.apply(this.isabelle, global()).retrieveNow(lConv, this.isabelle, global());	
		
		for(String thy: JavaConverters.asJava(thys)) {
			if(thy.startsWith(prefix)) {
				this.theoryNames.add(thy);
			}
		}
	}
	
	private void extractTheorems() {
		this.theorems = new HashMap<String, Map<String, String>>();
		
		MLFunction<Theory, scala.collection.immutable.List<String>> mlFun = 
				MLFunction.compileFunction("fn thy => map (fn x => fst (snd x)) (Global_Theory.dest_thm_names thy) ", 
				this.isabelle, 
				global(), 
				Implicits.theoryConverter(), 
				lConv);
		
		for(String thyName: this.theoryNames) {
			Map<String, String> toBeFilled = new HashMap<String, String>();
			this.theorems.put(thyName, toBeFilled);
			
			Context ctxt = Context.apply(thyName, this.isabelle, global());
			Theory theory = ctxt.theoryOf(this.isabelle, global());
			
			scala.collection.immutable.List<String> defs = mlFun.apply(theory, this.isabelle, global(), Implicits.theoryConverter()).retrieveNow(lConv, this.isabelle, global());
			
			for(int i=0; i<defs.length(); i++) {
				String thmName = defs.apply(i);
				
				// This filters out all theorems generated by Isabelle for internal usage.
				if(thmName.matches(".*\\..*\\..*")) {
					continue;
				}
				
				try {
					MLFunction<Theory,Thm> thmFun = MLFunction.compileFunction("fn thy => Global_Theory.get_thm thy \"" + thmName + "\"", this.isabelle, global(), Implicits.theoryConverter(), Implicits.thmConverter());
					Thm thm = thmFun.apply(theory, this.isabelle, global(), Implicits.theoryConverter()).retrieveNow(Implicits.thmConverter(), this.isabelle, global());
					String pretty = thm.prettyRaw(ctxt, global());
					
					toBeFilled.put(thmName, pretty);
				} catch (Exception e) {
					System.out.println(e);
				}
			}
		}
	}
	
	public void extractFunctionsAndDefinitions() {
		this.functionsAndDefinitions = new HashMap<String, Map<String,String>>();
		
		MLFunction<Theory, scala.collection.immutable.List<String>> mlFunToExtractAllNames = MLFunction.compileFunction(
				"fn thy => "
				+ "(map "
					+ "(fn x => "
						+ "(#description "
							+ "(hd "
								+ "(snd(x))"
							+ ")"
						+ ")"
					+ ") "
					+ "(filter "
						+ "(fn x => "
							+ "(String.isPrefix "
								+ "(Context.theory_name thy) "
								+ "(snd (fst (x))"
							+ ")"
						+ ")"
					+ ")"
				+ "(Defs.all_specifications_of (Theory.defs_of thy))))", this.isabelle, global(), Implicits.theoryConverter(), lConv);
		
		MLFunction<Theory, scala.collection.immutable.List<String>> mlFunToExtractConsts = MLFunction.compileFunction(
				"fn thy => #constants (Consts.dest (Sign.consts_of thy))", this.isabelle, global(), Implicits.theoryConverter(), lConv);
		
		for(String thyName: this.theoryNames) {
			Map<String, String> toBeFilled = new HashMap<String, String>();
			this.theorems.put(thyName, toBeFilled);
			
			Context ctxt = Context.apply(thyName, this.isabelle, global());
			Theory theory = ctxt.theoryOf(this.isabelle, global());
			
			List<String> names = JavaConverters.asJava(mlFunToExtractAllNames.apply(theory.mlValue(), this.isabelle, global()).retrieveNow(lConv, this.isabelle, global()));
			List<String> filteredNames = new LinkedList<String>();
			
			List
			
			for(String name: names) {
				if(name.endsWith("_def") || name.endsWith("_def_raw")) {
					name = name.replace("_raw", "");
					name = name.replace("_def", "");
					
					if(name.endsWith("_rel") || name.endsWith("_graph") || name.endsWith("_sumC")) {
						continue;
					}
					
					filteredNames.add(name);
					System.out.println(name);
				}
			}
			
			
		}
	}
	
	/*
	 * Required, as StringConverter cannot be instantiated.
	 */
	private static class JavaStringConverter extends Converter<String> {

		@Override
		public String exnToValue(Isabelle isabelle, ExecutionContext ec) {
			return StringConverter.exnToValue(isabelle, ec);
		}

		@Override
		public String mlType(Isabelle isabelle, ExecutionContext ec) {
			return StringConverter.mlType(isabelle, ec);
		}

		@Override
		public Future<String> retrieve(MLValue<String> value, Isabelle isabelle, ExecutionContext ec) {
			return StringConverter.retrieve(value, isabelle, ec);
		}

		@Override
		public MLValue<String> store(String value, Isabelle isabelle, ExecutionContext ec) {
			return StringConverter.store(value, isabelle, ec);
		}

		@Override
		public String valueToExn(Isabelle isabelle, ExecutionContext ec) {
			return StringConverter.valueToExn(isabelle, ec);
		}
		
	}
}
