theory Rules_For_Electing
  imports "../Properties/Electing"
          "../Properties/Non_Blocking"
          "../Properties/Defers"
          "../Components/Basic_Modules/Elect_Module"
          "../Components/Basic_Modules/Plurality_Module"
          "../Components/Composites/Elect_Composition"
          Rules_For_Non_Blocking

begin

theorem electing_imp_non_blocking:
  assumes electing: "electing m"
  shows "non_blocking m"
  using Diff_disjoint Diff_empty Int_absorb2 electing
        defer_in_alts elect_in_alts electing_def
        non_blocking_def reject_not_elec_or_def
  by (smt (verit, ccfv_SIG))

theorem elect_mod_electing[simp]: "electing elect_module"
  unfolding electing_def
  by simp

lemma plurality_electing2: "∀A p.
                              (A ≠ {} ∧ finite_profile A p) ⟶
                                elect plurality A p ≠ {}"
proof (intro allI impI conjI)
  fix
    A :: "'a set" and
    p :: "'a Profile"
  assume
    assm0: "A ≠ {} ∧ finite_profile A p"
  show
    "elect plurality A p ≠ {}"
  proof
    obtain max where
      max: "max = Max(win_count p ` A)"
      by simp
    then obtain a where
      a: "win_count p a = max ∧ a ∈ A"
      using Max_in assm0 empty_is_image
            finite_imageI imageE
      by (metis (no_types, lifting))
    hence
      "∀x ∈ A. win_count p x ≤ win_count p a"
      by (simp add: max assm0)
    moreover have
      "a ∈ A"
      using a
      by simp
    ultimately have
      "a ∈ {a ∈ A. ∀x ∈ A. win_count p x ≤ win_count p a}"
      by blast
    hence a_elem:
      "a ∈ elect plurality A p"
      by simp
    assume
      assm1: "elect plurality A p = {}"
    thus "False"
      using a_elem assm1 all_not_in_conv
      by metis
  qed
qed

(*The plurality module is electing.*)
theorem plurality_electing[simp]: "electing plurality"
proof -
  have "electoral_module plurality ∧
      (∀A p. (A ≠ {} ∧ finite_profile A p) ⟶ elect plurality A p ≠ {})"
  proof
    show "electoral_module plurality"
      by simp
  next
    show "(∀A p. (A ≠ {} ∧ finite_profile A p) ⟶ elect plurality A p ≠ {})"
      using plurality_electing2
      by metis
  qed
  thus ?thesis
      by (simp add: electing_def)
  qed

theorem elector_electing[simp]:
  assumes
    module_m: "electoral_module m" and
    non_block_m: "non_blocking m"
  shows "electing (elector m)"
proof -
  obtain
    AA :: "'a Electoral_Module ⇒ 'a set" and
    rrs :: "'a Electoral_Module ⇒ 'a Profile" where
    f1:
    "∀f.
      (electing f ∨
        {} = elect f (AA f) (rrs f) ∧ profile (AA f) (rrs f) ∧
            finite (AA f) ∧ {} ≠ AA f ∨
        ¬ electoral_module f) ∧
            ((∀A rs. {} ≠ elect f A rs ∨ ¬ profile A rs ∨
                infinite A ∨ {} = A) ∧
            electoral_module f ∨
        ¬ electing f)"
    using electing_def
    by metis
  have non_block:
    "non_blocking
      (elect_module::'a set ⇒ _ Profile ⇒ _ Result)"
    by (simp add: electing_imp_non_blocking)
  thus ?thesis
    (* using f1 Diff_empty elect_module.elims elector.simps non_block_m
          non_blocking_def reject_not_elec_or_def seq_comp_defers_def_set
          seq_comp_presv_non_blocking snd_conv elect_mod_sound fst_conv
          elect_module.simps elector_sound module_m disjoint3.cases
          empty_iff ex_in_conv seq_comp_def_set_trans *)
  proof -
    obtain
      AAa :: "'a Electoral_Module ⇒ 'a set" and
      rrsa :: "'a Electoral_Module ⇒ 'a Profile" where
      f1:
      "∀f.
        (electing f ∨
          {} = elect f (AAa f) (rrsa f) ∧ profile (AAa f) (rrsa f) ∧
              finite (AAa f) ∧ {} ≠ AAa f ∨
        ¬ electoral_module f) ∧ ((∀A rs. {} ≠ elect f A rs ∨
        ¬ profile A rs ∨ infinite A ∨ {} = A) ∧ electoral_module f ∨
        ¬ electing f)"
      using electing_def
      by metis
    obtain
      AAb :: "'a Result ⇒ 'a set" and
      AAc :: "'a Result ⇒ 'a set" and
      AAd :: "'a Result ⇒ 'a set" where
      f2:
      "∀p. (AAb p, AAc p, AAd p) = p"
      using disjoint3.cases
      by (metis (no_types))
    have f3:
      "electoral_module (elector m)"
      using elector_sound module_m
      by simp
    have f4:
      "∀p. (elect_r p, AAc p, AAd p) = p"
      using f2
      by simp
    have
      "finite (AAa (elector m)) ∧
        profile (AAa (elector m)) (rrsa (elector m)) ∧
        {} = elect (elector m) (AAa (elector m)) (rrsa (elector m)) ∧
        {} = AAd (elector m (AAa (elector m)) (rrsa (elector m))) ∧
        reject (elector m) (AAa (elector m)) (rrsa (elector m)) =
          AAc (elector m (AAa (elector m)) (rrsa (elector m))) ⟶
              electing (elector m)"
      using f2 f1 Diff_empty elector.simps non_block_m snd_conv
            non_blocking_def reject_not_elec_or_def non_block
            seq_comp_presv_non_blocking
      by metis
    moreover
    {
      assume
        "{} ≠ AAd (elector m (AAa (elector m)) (rrsa (elector m)))"
      hence
        "¬ profile (AAa (elector m)) (rrsa (elector m)) ∨
          infinite (AAa (elector m))"
        using f4
        by simp
    }
    ultimately show ?thesis
      using f4 f3 f1 fst_conv snd_conv
      by metis
  qed
qed

(*
   Composing an electoral module that defers exactly 1 alternative
   in sequence after an electoral module that is electing
   results (still) in an electing electoral module.
*)
theorem seq_comp_electing[simp]:
  assumes def_one_m1:  "defers 1 m1" and
          electing_m2: "electing m2"
  shows "electing (m1 ▹ m2)"
proof -
  have
    "∀A p. (card A ≥ 1 ∧ finite_profile A p) ⟶
        card (defer m1 A p) = 1"
    using def_one_m1 defers_def
    by blast
  hence
    "∀A p. (A ≠ {} ∧ finite_profile A p) ⟶
        defer m1 A p ≠ {}"
    using One_nat_def Suc_leI card_eq_0_iff
          card_gt_0_iff zero_neq_one
    by metis
  thus ?thesis
    using Un_empty def_one_m1 defers_def electing_def
          electing_m2 seq_comp_def_then_elect_elec_set
          seq_comp_sound def_presv_fin_prof
    by (smt (verit, ccfv_threshold))
qed

end