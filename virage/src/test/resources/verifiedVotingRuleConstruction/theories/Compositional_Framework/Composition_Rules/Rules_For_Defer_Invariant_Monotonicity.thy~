theory Rules_For_Defer_Invariant_Monotonicity
  imports "../Properties/Defer_Invariant_Monotonicity"
          "../Properties/Non_Electing"
          "../Properties/Invariant_Monotonicity"
          "../Components/Compositional_Structures/Revision_Composition"
          Rules_For_Non_Electing

begin

(*
   Revising an invariant monotone electoral module results in a
   defer-invariant-monotone electoral module.
*)
theorem rev_comp_def_inv_mono[simp]:
  assumes "invariant_monotonicity m"
  shows "defer_invariant_monotonicity (m↓)"
proof -
  have "∀A p q w. (w ∈ defer (m↓) A p ∧ lifted A p q w) ⟶
                  (defer (m↓) A q = defer (m↓) A p ∨ defer (m↓) A q = {w})"
    using assms
    by (simp add: invariant_monotonicity_def)
  moreover have "electoral_module (m↓)"
    using assms rev_comp_sound invariant_monotonicity_def
    by auto
  moreover have "non_electing (m↓)"
    using assms rev_comp_non_electing invariant_monotonicity_def
    by auto
  ultimately have "electoral_module (m↓) ∧ non_electing (m↓) ∧
      (∀A p q w. (w ∈ defer (m↓) A p ∧ lifted A p q w) ⟶
                 (defer (m↓) A q = defer (m↓) A p ∨ defer (m↓) A q = {w}))"
    by blast
  thus ?thesis
    using defer_invariant_monotonicity_def
    by (simp add: defer_invariant_monotonicity_def)
qed

end