theory Rules_For_Non_Blocking
  imports "../Properties/Non_Blocking"
          "../Properties/Non_Electing"
          "../Properties/Electing"
          "../Components/Basic_Modules/Pass_Module"
          "../Components/Compositional_Structures/Revision_Composition"
          "../Components/Compositional_Structures/Sequential_Composition"

begin

(*The pass module is non-blocking.*)
theorem pass_mod_non_blocking[simp]:
  assumes order: "linear_order r" and
          g0_n:  "n > 0"
        shows "non_blocking (pass_module n r)"
  unfolding non_blocking_def
proof (safe, simp_all)
  show "electoral_module (pass_module n r)"
    using pass_mod_sound order
    by simp
next
  fix
    A :: "'a set" and
    p :: "'a Profile" and
    x :: "'a"
  assume
    fin_A: "finite A" and
    prof_A: "profile A p" and
    card_A:
    "{a ∈ A. n <
      card (above
        {(a, b). (a, b) ∈ r ∧
          a ∈ A ∧ b ∈ A} a)} = A" and
    x_in_A: "x ∈ A"
  have lin_ord_A:
    "linear_order_on A (limit A r)"
    using limit_presv_lin_ord order top_greatest
    by metis
  have
    "∃a∈A. above (limit A r) a = {a} ∧
      (∀x∈A. above (limit A r) x = {x} ⟶ x = a)"
    using above_one fin_A lin_ord_A x_in_A
    by blast
  hence not_all:
    "{a ∈ A. card(above (limit A r) a) > n} ≠ A"
    using One_nat_def Suc_leI assms(2) is_singletonI
          is_singleton_altdef leD mem_Collect_eq
    by (metis (no_types, lifting))
  hence "reject (pass_module n r) A p ≠ A"
    by simp
  thus "False"
    using order card_A
    by simp
qed

(*
   Revising an electing electoral module results in a
   non-blocking electoral module.
*)
theorem rev_comp_non_blocking[simp]:
  assumes "electing m"
  shows "non_blocking (m↓)"
  unfolding non_blocking_def
proof (safe, simp_all)
  show "electoral_module (m↓)"
    using assms electing_def rev_comp_sound
    by (metis (no_types, lifting))
next
  fix
    A :: "'a set" and
    p :: "'a Profile" and
    x :: "'a"
  assume
    fin_A: "finite A" and
    prof_A: "profile A p" and
    no_elect: "A - elect m A p = A" and
    x_in_A: "x ∈ A"
  from no_elect have non_elect:
    "non_electing m"
    using assms prof_A x_in_A fin_A electing_def empty_iff
          Diff_disjoint Int_absorb2 elect_in_alts
    by (metis (no_types, lifting))
  show "False"
    using non_elect assms electing_def empty_iff fin_A
          non_electing_def prof_A x_in_A
    by (metis (no_types, lifting))
qed

(*The sequential composition preserves the non-blocking property.*)
theorem seq_comp_presv_non_blocking[simp]:
  assumes
    non_blocking_m: "non_blocking m" and
    non_blocking_n: "non_blocking n"
  shows "non_blocking (m ▹ n)"
proof -
  fix
    A :: "'a set" and
    p :: "'a Profile"
  let ?input_sound = "((A::'a set) ≠ {} ∧ finite_profile A p)"
  from non_blocking_m have
    "?input_sound ⟶ reject m A p ≠ A"
    by (simp add: non_blocking_def)
  with non_blocking_m have 0:
    "?input_sound ⟶ A - reject m A p ≠ {}"
    using Diff_eq_empty_iff non_blocking_def
          reject_in_alts subset_antisym
    by metis
  from non_blocking_m have
    "?input_sound ⟶ well_formed A (m A p)"
    by (simp add: electoral_module_def non_blocking_def)
  hence
    "?input_sound ⟶
        elect m A p ∪ defer m A p = A - reject m A p"
    using non_blocking_def non_blocking_m elec_and_def_not_rej
    by metis
  with 0 have
    "?input_sound ⟶ elect m A p ∪ defer m A p ≠ {}"
    by auto
  hence "?input_sound ⟶ (elect m A p ≠ {} ∨ defer m A p ≠ {})"
    by simp
  with non_blocking_m non_blocking_n
  show ?thesis
    using Diff_empty Diff_subset_conv Un_empty fst_conv snd_conv
          defer_not_elec_or_rej elect_in_alts inf.absorb1 sup_bot_right
          non_blocking_def reject_in_alts sequential_composition.simps
          seq_comp_sound def_presv_fin_prof result_disj subset_antisym
    by (smt (verit))
qed

end