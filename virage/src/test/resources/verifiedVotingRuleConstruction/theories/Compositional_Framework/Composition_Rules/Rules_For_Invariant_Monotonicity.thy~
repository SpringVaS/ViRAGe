theory Rules_For_Invariant_Monotonicity
  imports "../Properties/Invariant_Monotonicity"
          "../Components/Basic_Modules/Plurality_Module"

begin

lemma plurality_inv_mono2: "∀A p q a.
                              (a ∈ elect plurality A p ∧ lifted A p q a) ⟶
                                (elect plurality A q = elect plurality A p ∨
                                    elect plurality A q = {a})"
proof (intro allI impI)
  fix
    A :: "'a set" and
    p :: "'a Profile" and
    q :: "'a Profile" and
    a :: "'a"
  assume
    asm1:
    "a ∈ elect plurality A p ∧ lifted A p q a"
  show
    "elect plurality A q = elect plurality A p ∨
        elect plurality A q = {a}"
  proof -
    have lifted_winner:
      "∀x ∈ A.
         ∀i::nat. i < length p ⟶
           (above (p!i) x = {x} ⟶
              (above (q!i) x = {x} ∨ above (q!i) a = {a}))"
      using asm1 Profile.lifted_def lifted_above_winner
      by (metis (no_types, lifting))
    hence
      "∀i::nat. i < length p ⟶
          (above (p!i) a = {a} ⟶ above (q!i) a = {a})"
      using asm1
      by auto
    hence a_win_subset:
      "{i::nat. i < length p ∧ above (p!i) a = {a}} ⊆
          {i::nat. i < length p ∧ above (q!i) a = {a}}"
      by blast
    moreover have sizes:
      "length p = length q"
      using asm1 Profile.lifted_def
      by metis
    ultimately have win_count_a:
      "win_count p a ≤ win_count q a"
      by (simp add: card_mono)
    have fin_A:
      "finite A"
      using asm1 Profile.lifted_def
      by metis
    hence
      "∀x ∈ A-{a}.
        ∀i::nat. i < length p ⟶
          (above (q!i) a = {a} ⟶ above (q!i) x ≠ {x})"
      using DiffE Profile.lifted_def above_one2
            asm1 insertCI insert_absorb insert_not_empty
            profile_def sizes
      by metis
    with lifted_winner have above_QtoP:
      "∀x ∈ A-{a}.
        ∀i::nat. i < length p ⟶
          (above (q!i) x = {x} ⟶ above (p!i) x = {x})"
      using lifted_above_winner3 asm1
            Profile.lifted_def
      by metis
    hence
      "∀x ∈ A-{a}.
        {i::nat. i < length p ∧ above (q!i) x = {x}} ⊆
          {i::nat. i < length p ∧ above (p!i) x = {x}}"
      by (simp add: Collect_mono)
    hence win_count_other:
      "∀x ∈ A-{a}. win_count p x ≥ win_count q x"
      by (simp add: card_mono sizes)
    show
      "elect plurality A q = elect plurality A p ∨
           elect plurality A q = {a}"
    proof cases
      assume "win_count p a = win_count q a"
      hence
        "card {i::nat. i < length p ∧ above (p!i) a = {a}} =
              card {i::nat. i < length p ∧ above (q!i) a = {a}}"
        by (simp add: sizes)
      moreover have
        "finite {i::nat. i < length p ∧ above (q!i) a = {a}}"
        by simp
      ultimately have
        "{i::nat. i < length p ∧ above (p!i) a = {a}} =
              {i::nat. i < length p ∧ above (q!i) a = {a}}"
        using a_win_subset
        by (simp add: card_subset_eq)
      hence above_pq:
        "∀i::nat. i < length p ⟶
            above (p!i) a = {a} ⟷ above (q!i) a = {a}"
        by blast
      moreover have
        "∀x ∈ A-{a}.
          ∀i::nat. i < length p ⟶
            (above (p!i) x = {x} ⟶
              (above (q!i) x = {x} ∨ above (q!i) a = {a}))"
        using lifted_winner
        by auto
      moreover have
        "∀x ∈ A-{a}.
          ∀i::nat. i < length p ⟶
            (above (p!i) x = {x} ⟶ above (p!i) a ≠ {a})"
      proof (rule ccontr)
        assume
          "¬(∀x ∈ A-{a}.
              ∀i::nat. i < length p ⟶
                (above (p!i) x = {x} ⟶ above (p!i) a ≠ {a}))"
        hence
          "∃x ∈ A-{a}.
            ∃i::nat.
              i < length p ∧ above (p!i) x = {x} ∧ above (p!i) a = {a}"
          by auto
        moreover from this have
          "finite A ∧ A ≠ {}"
          using fin_A
          by blast
        moreover from asm1 have
          "∀i::nat. i < length p ⟶ linear_order_on A (p!i)"
          by (simp add: Profile.lifted_def profile_def)
        ultimately have
          "∃x ∈ A-{a}. x = a"
          using above_one2
          by metis
        thus "False"
          by simp
      qed
      ultimately have above_PtoQ:
        "∀x ∈ A-{a}.
          ∀i::nat. i < length p ⟶
            (above (p!i) x = {x} ⟶ above (q!i) x = {x})"
        by (simp add: above_pq)
      hence
        "∀x ∈ A.
          card {i::nat. i < length p ∧ above (p!i) x = {x}} =
            card {i::nat. i < length q ∧ above (q!i) x = {x}}"
        using Collect_cong DiffI above_pq above_QtoP
              insert_absorb insert_iff insert_not_empty sizes
        by (smt (verit, ccfv_threshold))
      hence "∀x ∈ A. win_count p x = win_count q x"
        by simp
      hence
        "{a ∈ A. ∀x ∈ A. win_count p x ≤ win_count p a} =
            {a ∈ A. ∀x ∈ A. win_count q x ≤ win_count q a}"
        by auto
      thus ?thesis
        by simp
    next
      assume "win_count p a ≠ win_count q a"
      hence strict_less:
        "win_count p a < win_count q a"
        using win_count_a
        by auto
      have a_in_win_p:
        "a ∈ {a ∈ A. ∀x ∈ A. win_count p x ≤ win_count p a}"
        using asm1
        by auto
      hence "∀x ∈ A. win_count p x ≤ win_count p a"
        by simp
      with strict_less win_count_other
      have less:
        "∀x ∈ A-{a}. win_count q x < win_count q a"
        using DiffD1 antisym dual_order.trans
              not_le_imp_less win_count_a
        by metis
      hence
        "∀x ∈ A-{a}. ¬(∀y ∈ A. win_count q y ≤ win_count q x)"
        using asm1 Profile.lifted_def not_le
        by metis
      hence
        "∀x ∈ A-{a}.
          x ∉ {a ∈ A. ∀x ∈ A. win_count q x ≤ win_count q a}"
        by blast
      hence
        "∀x ∈ A-{a}. x ∉ elect plurality A q"
        by simp
      moreover have
        "a ∈ elect plurality A q"
      proof -
        from less
        have
          "∀x ∈ A-{a}. win_count q x ≤ win_count q a"
          using less_imp_le
          by metis
        moreover have
          "win_count q a ≤ win_count q a"
          by simp
        ultimately have
          "∀x ∈ A. win_count q x ≤ win_count q a"
          by auto
        moreover have
          "a ∈ A"
          using a_in_win_p
          by auto
        ultimately have
          "a ∈ {a ∈ A.
              ∀x ∈ A. win_count q x ≤ win_count q a}"
          by auto
        thus ?thesis
          by simp
      qed
      moreover have
        "elect plurality A q ⊆ A"
        by simp
      ultimately show ?thesis
        by auto
    qed
  qed
qed

(*The plurality rule is invariant monotone.*)
theorem plurality_inv_mono[simp]: "invariant_monotonicity plurality"
proof -
  have
    "electoral_module plurality ∧
      (∀A p q a.
        (a ∈ elect plurality A p ∧ lifted A p q a) ⟶
          (elect plurality A q = elect plurality A p ∨
            elect plurality A q = {a}))"
  proof
    show "electoral_module plurality"
      by simp
  next
    show
      "∀A p q a. (a ∈ elect plurality A p ∧ lifted A p q a) ⟶
          (elect plurality A q = elect plurality A p ∨
            elect plurality A q = {a})"
      using plurality_inv_mono2
      by metis
  qed
  thus ?thesis
    by (simp add: invariant_monotonicity_def)
qed

end