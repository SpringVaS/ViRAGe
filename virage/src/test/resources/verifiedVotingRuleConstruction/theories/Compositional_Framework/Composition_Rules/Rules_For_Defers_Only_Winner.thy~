theory Rules_For_Defers_Only_Winner
  imports "../Properties/Defers_Only_Winner"
          "../Properties/Defer_Deciding"
          "../Properties/Condorcet_Compatibility"
          "../Properties/Non_Electing"

begin

lemma ccomp_and_dd_imp_def_only_winner:
  assumes ccomp: "condorcet_compatibility m" and
          dd: "defer_deciding m" and
          winner: "condorcet_winner A p w"
  shows "defer m A p = {w}"
proof (rule ccontr)
  assume not_w: "defer m A p \<noteq> {w}"
  from dd have def_1:
    "defers 1 m"
    using defer_deciding_def
    by metis
  hence c_win:
    "finite_profile A p \<and>  w \<in> A \<and> (\<forall>x \<in> A - {w} . wins w p x)"
    using winner
    by simp
  hence "card (defer m A p) = 1"
    using One_nat_def Suc_leI card_gt_0_iff
          def_1 defers_def equals0D
    by metis
  hence 0: "\<exists>x \<in> A . defer m A p ={x}"
    using card_1_singletonE dd defer_deciding_def
          defer_in_alts insert_subset c_win
    by metis
  with not_w have "\<exists>l \<in> A . l \<noteq> w \<and> defer m A p = {l}"
    by metis
  hence not_in_defer: "w \<notin> defer m A p"
    by auto
  have "non_electing m"
    using dd defer_deciding_def
    by metis
  hence not_in_elect: "w \<notin> elect m A p"
    using c_win equals0D non_electing_def
    by metis
  from not_in_defer not_in_elect have one_side:
    "w \<in> reject m A p"
    using ccomp condorcet_compatibility_def c_win
          electoral_mod_defer_elem
    by metis
  from ccomp have other_side: "w \<notin> reject m A p"
    using condorcet_compatibility_def c_win winner
    by (metis (no_types, hide_lams))
  thus False
    by (simp add: one_side)
qed

end